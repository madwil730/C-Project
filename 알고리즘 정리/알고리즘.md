# 알고리즘
### 알고리즘: 문제를 해결하기위한 일련의 절차를 공식화한 형태로 표현한것  
좋은 알고리즘을 만들기 위해서는 다음과 같은 조건을 충족시켜야 한다

* 입력 : 외부에서 제공되는 자료가 0개 이상 존재한다  
* 출력 : 적어도 2개 이상의 서로 다른 결과를 내어야 한다. 즉 모든 입력에 하나의 출력- 이 나오면 안 된다  
* 명확성 : 수행 과정은 명확하고 모호하지 않은 명령어로 구성되어야 한다  
* 유한성 : 유한 번의 명령어를 수행 후 유한 시간 내에 종료한다  
* 효율성 : 모든 과정은 명백하게 실행 가능(검증 가능)한 것이어야 한다

![캡처](https://github.com/madwil730/C-Project/assets/65881884/c3195d18-54a8-403f-a788-4d7c6f01d79e)


###  검색알고리즘

#### 1-1) 선형검색(Liner Serch) : 복잡도 O(n)

* 배열을 검색하여 원하는 key값을 찾는 알고리즘
* 배열의 맨앞부터 순차적으로 훑어가며 검색한다

#### 1-2) 이진검색(Binary Serch) : 복잡도 O(log(n))

* 정렬된 배열에서 원하는 key값을 찾는 알고리즘
* 선형검색보다 빠르다

### 2. 재귀알고리즘

#### 2-1) 피보나치 수열 : 복잡도 O(2^n)

피보나치 수열은 다음과 같이 무한대로 이어지는 수열
  예)  0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55.......

#### 2-2) 최대공약수(GCD) : 복잡도 O(log(n+m))


#### 2-3) 하노이의 탑알고리즘

### 3. 정렬알고리즘

#### 3-1) 선택정렬(Selection Sort) : 복잡도 O(n^2)
리스트안에 있는 자료들(소->대) 순서로 나열  

#### 3-2) 삽입정렬(Insertion Sort) : 복잡도 O(n)~ O(n^2)의 사이

#### 3-3) 병합정렬(Merge Sort) : 복잡도 O(log(n))

재귀호출을 사용하는 정렬

#### 3-4) Quick Sort : 복잡도 O(log(n))

#### 3-5) Bubble Sort : 복잡도 O(n^2)
